\documentclass[a4paper, twoside]{report}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{multicol}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Project Title}
\author{John Smith}
% Update supervisor and other title stuff in title/title.tex

\begin{document}
\input{title/title.tex}

%\chapter{Group Organization}

\section*{1. Group Organization}

\subsection*{1.1 Task Sharing}
Our group decided to split the tasks according to the different instructions: MULTIPLY, SINGLE DATA TRANSFER, DATA PROCESSING and BRANCH. This was thought so we can think about how only one of these work, and then figure out how do the main program works together.
Therefore, our intention was to begin with the design of each of the instructions and to move onto the general design once we knew how do the most specific tasks work.
In the main program, some of us started implementing the basic functions, to begin with the ‘skeleton’ that was going to be implemented and corrected by the others. That gave us the possibility of working faster, and the mistakes were quickly amended.


We split the four functions - Multiply, Single Data Transfer, Data Processing, and Branch - among ourselves, and proceeded to implement these in our own ways based on the memory implementation we agreed on. 

\subsection*{1.2 Co-ordination}
Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et 
neque pharetra sollicitudin.  Praesent imperdietmi nec ante. 
Donec ullamcorper, felis non sodales...Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do 
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut 
enim ad minim veniam, quis nostrud exercitation ullamco laboris..
 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do 
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut 
enim ad minim veniam, quis nostrud exercita...

\section*{}


\section*{2. Working as a group}
While starting out, we had a hard time trying to figure out what to do and where to start. We divided the work among ourselves, but soon realized that we would have to get together and decide how to implement the ARM-11 processor's memory in C, before we could move on working individually. 
We set up groups on project management applications- Trello to co-ordinate requirements, deadlines and ideas for extensions, and Google Drive to piece together and edit reports before putting them in a \LaTeX file. We comment our code extensively to make the code understandable to other group members. In addition to collaborating on Google Drive and using a Facebook to share links (StackOverflow, reddit et al), we work together in labs to make discussion and implementation of new design ideas and debugging of code easier. \\
The main problems we've faced so far is repository management (gitlab) and issues with our IDE (CLion). Learning git on-the-go was challenging, but a few deleted branches and merge conflicts later, we're quite confident that it's no longer an issue.

\subsection*{2.1 Adapting to future tasks}

For future tasks, we plan on discussing the basic design (structs, header files and such) before dividing the work between ourselves. We expect it to be a lot easier to get started seeing how we already have a working basic implementation, and are now no longer git amateurs learning by trial-and-error. Taking advantage of third-party software such as Valgrind and DynamoRIO, working from the terminal more often on the off-chance that CLion fails us, and creating our own makefiles is on our to-do list. 
\section*{}

\section*{3. Emulator implementation}
Initially, we decided that the best way to implement the ARM-11 processor would be to have a single struct with arrays to represent the memory and registers, and a struct to represent an instruction and its components. As per the spec, we were dealing with 32-bit integers, so \verb|uint32_t| was the obvious choice for low level representation and implementation. \\
After a meeting with our supervisor, it would be much more convenient to separate the CPU part (registers et al) and the memory (\verb|uint32_t memory[16384]|), and have them as data member of an all encompassing third struct. As it stands, this is how the ARM-11 machine has been implemented:
\begin{lstlisting} 
typedef struct{
    uint32_t memoryAlloc[16384];
} MEMORY;

typedef struct{
    uint32_t registers[17];
    uint32_t fetchedInstruction;
    instruction *decodedInstruction;
} CPU;

typedef struct {
    MEMORY mem;
    CPU c ;
} MACHINE;

\end{lstlisting}

\subsubsection*{3.1 Reusable Parts}


\section*{}

\section*{4. Possible roadblocks}
At the moment, we're unsure of how Part-3 will turn out, as none of us have worked with a Raspberry Pi before. However, some of us have worked with Arduinos extensively, so we're not as anxious about that as we are about the challenge of interfacing our code with the hardware. \\ 
As for Part 4, the problem right now is that we have \textit{too many} good ideas, and we're not able to decide upon which we want to go ahead with. \\
We've run into problems with debugging and CLion, and we expect to face them again in the coming weeks
\subsection*{4.1 Solutions planned}
We've all started watching an extensive tutorial series on YouTube which explains the working of a Raspberry Pi ground up, and we expect that finishing said tutorial series will make our experience with working the RPi much easier. \\
We have decided to have a group meeting where we will weigh the pros and cons of each idea for the extension, and make sure that we decide upon something that is in line with our limited experience in C and within the given time frame. \\
We have started writing our own Makefiles, and have all agreed upon what settings to work with within CLion. As for debugging, we plan to make extensive use of Valgrind and gdb, as opposed to  the rudimentary debugging we've carried out so far with printf statements and assertions. 











\end{document}